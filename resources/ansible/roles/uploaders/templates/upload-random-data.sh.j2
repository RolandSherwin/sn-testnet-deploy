#!/usr/bin/env bash
LOG_OUTPUT_DEST="{{ log_output_dest }}"

if [[ -n "${SECRET_KEY}" ]] && ! grep -q "export SECRET_KEY=" ~/.profile; then
  echo "export SECRET_KEY=${SECRET_KEY}" >> ~/.profile
fi

if [[ -n "${RPC_URL}" ]] && ! grep -q "export RPC_URL=" ~/.profile; then
  echo "export RPC_URL=${RPC_URL}" >> ~/.profile
fi

if [[ -n "${PAYMENT_TOKEN_ADDRESS}" ]] && ! grep -q "export PAYMENT_TOKEN_ADDRESS=" ~/.profile; then
  echo "export PAYMENT_TOKEN_ADDRESS=${PAYMENT_TOKEN_ADDRESS}" >> ~/.profile
fi

if [[ -n "${DATA_PAYMENTS_ADDRESS}" ]] && ! grep -q "export DATA_PAYMENTS_ADDRESS=" ~/.profile; then
  echo "export DATA_PAYMENTS_ADDRESS=${DATA_PAYMENTS_ADDRESS}" >> ~/.profile
fi

if [[ -n "${EVM_NETWORK}" ]] && ! grep -q "export EVM_NETWORK=" ~/.profile; then
  echo "export EVM_NETWORK=${EVM_NETWORK}" >> ~/.profile
fi

CONTACT_PEER_ARG=""
NETWORK_CONTACTS_URL_ARG=""
NETWORK_ID_ARG=""
TESTNET_ARG=""

if [ -n "${1:-}" ]; then
  echo "Setting contact peer arg to ${1:-}"
  CONTACT_PEER_ARG="--peer ${1:-}"
fi
if [ -n "${2:-}" ]; then
  echo "Setting network contacts URL arg to ${2:-}"
  NETWORK_CONTACTS_URL_ARG="--network-contacts-url ${2:-}"
fi
if [ -n "${3:-}" ]; then
  echo "Setting network ID arg to ${3:-}"
  NETWORK_ID_ARG="--network-id ${3:-}"
  echo "Setting --testnet arg"
  TESTNET_ARG="--testnet"
fi


if ! command -v ant &> /dev/null; then
  echo "Error: 'ant' not found in PATH."
  exit 1
fi


get_error_enum() {
  local exit_code=$1
  case $exit_code in
    0)
      echo "SUCCESS"
      ;;
    6)
      echo "INVALID_INPUT"
      ;;
    11)
      echo "SERIALIZATION_ERROR"
      ;;
    12)
      echo "IO_ERROR"
      ;;
    13)
      echo "NETWORK_ERROR"
      ;;
    14)
      echo "PROTOCOL_ERROR"
      ;;
    15)
      echo "SELF_ENCRYPTION_ERROR"
      ;;
    21)
      echo "EVM_WALLET_NETWORK_MISMATCH"
      ;;
    22)
      echo "EVM_WALLET_ERROR"
      ;;
    23)
      echo "PAY_COST_ERROR"
      ;;
    31)
      echo "INVALID_DATA_MAP"
      ;;
    32)
      echo "DECRYPTION_ERROR"
      ;;
    36)
      echo "UNRECOGNIZED_INPUT"
      ;;
    37)
      echo "FAILED_GET"
      ;;
    41)
      echo "PUT_COST_ERROR"
      ;;
    42)
      echo "WALLET_ERROR"
      ;;
    43)
      echo "SCRATCHPAD_BAD_OWNER"
      ;;
    44)
      echo "PAYMENT_UNEXPECTEDLY_INVALID"
      ;;
    45)
      echo "PAYEES_MISSING"
      ;;
    51)
      echo "NO_BOOTSTRAP_PEERS_FOUND"
      ;;
    52)
      echo "FAILED_TO_PARSE_CACHE_DATA"
      ;;
    53)
      echo "COULD_NOT_OBTAIN_DATA_DIR"
      ;;
    54)
      echo "FAILED_TO_OBTAIN_ADDRS_FROM_URL"
      ;;
    55)
      echo "FAILED_TO_PARSE_URL"
      ;;
    56)
      echo "JSON_ERROR"
      ;;
    57) 
      echo "HTTP_ERROR"
      ;;
    58)
      echo "LOCK_ERROR"
      ;;
    *)
      echo "UNKNOWN_ERROR"
      ;;
  esac
}

write_metrics_on_success() {
  local time=$1
  local file_size_kb=$2
  local exit_code=$3
  metrics_header
  number_of_chunks=$(echo "$stdout" | rg -o 'Number of chunks uploaded: [0-9]+' | rg -o '[0-9]+')
  store_cost=$(echo "$stdout" | rg -o 'Total cost: [0-9]+' | rg -o '[0-9]+' | head -n 1)
  error_enum=$(get_error_enum $exit_code)

  echo "$time,$file_size_kb,$number_of_chunks,$store_cost,$exit_code" >> "./uploader_metrics.csv"
}

write_metrics_on_failure() {
  local time=$1
  local file_size_kb=$2
  local exit_code=$3
  metrics_header
  error_enum=$(get_error_enum $exit_code)
  echo "$time,$file_size_kb,0,0,$error_enum" >> "./uploader_metrics.csv"
}

metrics_header() {
  if [ ! -f "./uploader_metrics.csv" ]; then
    echo "Total Time(s),File Size (KB),Number of Chunks,Store Cost (AttoTokens),Exit Status" > "./uploader_metrics.csv"
  fi
}

generate_random_data_file_and_upload() {
  tmpfile=$(mktemp)
  dd if=/dev/urandom of="$tmpfile" bs=100M count=1 iflag=fullblock &> /dev/null

  echo "Generated random data file at $tmpfile"
  file_size_kb=$(du -k "$tmpfile" | cut -f1)

  timestamp=$(date +"%Y%m%d_%H%M%S")
  log_file_path="${LOG_OUTPUT_DEST}/${timestamp}"
  LOG_OUTPUT_ARG="--log-output-dest $log_file_path"
  
  now=$(date +"%s")
  stdout=$(ant \
    $CONTACT_PEER_ARG \
    $NETWORK_CONTACTS_URL_ARG \
    $TESTNET_ARG \
    $NETWORK_ID_ARG \
    $LOG_OUTPUT_ARG \
    file upload "$tmpfile" 2>&1)
  exit_code=$?
  echo "$stdout"
  echo "Exit code: $exit_code"

  if [ $? -eq 0 ]; then
    echo "Successfully uploaded $tmpfile using ANT CLI"

    file_ref=$(echo "$stdout" | grep -oP 'At address: \K\S+')
    if [ -z "$file_ref" ]; then
      echo "Error: Unable to extract file reference."
    else
      echo "$file_ref" >> "./uploaded_files.log"
    fi

    elapsed=$(($(date +"%s") - $now))
    write_metrics_on_success $elapsed $file_size_kb $exit_code
  else
    echo "Failed to upload $tmpfile using ANT CLI"
    elapsed=$(($(date +"%s") - $now))
    write_metrics_on_failure $elapsed $file_size_kb $exit_code
  fi

  rm "$tmpfile"
}

upload_count=0
while true; do
  echo "================================"
  echo "Generating and uploading file..."
  echo "================================"
  echo "$(date +"%A, %B %d, %Y %H:%M:%S")"
  generate_random_data_file_and_upload
  
  upload_count=$((upload_count + 1))
  
  {% if max_uploads is defined %}
  if [ $upload_count -ge {{ max_uploads }} ]; then
    # Sleeping indefinitely allows the service restart policy to be retained
    # such that the service would restart on errors.
    echo "Reached maximum upload count of {{ max_uploads }}, pausing uploads."
    while true; do
      sleep 3600
      echo "Maximum uploads ({{ max_uploads }}) reached. Service remains active but not uploading."
    done
  fi
  {% endif %}
  
  sleep 10
done
